! TinyBlog: Préparation

Ce tutorial va vous enseigner comment definir et deployer une application en utilisant Pharo/Seaside/Mongo ainsi que des frameworks disponibles en Pharo comme NeoJSON.
Nous allons définir un mini moteur de blogs. Les solutions proposées dans le tutorial sont parfois non optimale afin de vous faire réagir et que vous puissiez proposer d'autres solutions et améliorations.

D'autre part, notre objectif n'est pas d'être exhaustif. Nous montrons une facon de faire cependant nous invitons le lecteur à lire les références sur les autres chapitres, livres et tutoriaux afin d'approfondir son exp\'ertise.


!! Installation et préparation de Pharo

!!! Créer un projet sur SmalltalkHub
 
- Depuis votre compte créer un projet sur http://smalltalkhub.com
-- Nommez le "TinyBlog",
-- Récupérer l'URL du projet: 'http://smalltalkhub.com/mc/XXX/TinyBlog/main''

!!! Mettre en place Pharo

- Télécharger Pharo 4.0 à partir du site pharo.org
- A partir du "Configuration Browser", installer les paquets:
-- Seaside3,
-- VoyageMongo,
-- BootstrapMagritte,
-- Mustache
- Créez un paquet nommé TinyBlog,
- Créez un paquet nommé TinyBlog-Tests

!!! Créer la configuration du projet

- Créer un projet avec Versionner
-- Créer un nouveau projet "TinyBlog",
-- Dans development, ajoutez les paquets dont votre projet dépend:
--- Seaside3,
--- VoyageMongo,
--- BootstrapMagritte,
--- Mustache
-- Dans Packages, ajoutez le paquet TinyBlog,
--- Définissez son repository: 'http://smalltalkhub.com/mc/XXX/TinyBlog/main'
--- Cliquer sur le bouton "Save to development"

!!! Démarrer le serveur HTTP

- Aller dans Tools pour ouvrir le Seaside Control Panel,
- Faire un clic droit dans la partie supérieure et sélectionner le ZnZinServerAdaptor,
- Choisir le port 8080,
- Cliquer sur le serveur pour le sélectionner et cliquez sur le bouton "Start".


!! Mongo et sa configuration

@@todo a voir si on met cela plus tard apres le model
!!! Obtenir une base de données MongoDB

!!!! Dans le cloud avec MongoLab

- Se connecter sur *https://mongolab.com*
- Cliquer sur signup,
- Créer un compte utilisateur (un mail de vérification de l'adresse mail est envoyé. Il faut confirmer le compte).
- Cliquer sur "Create New"
- modèle d'hébergement: option "Single-node" et on sélectionne "Sandbox" (gratuit pour 0.5 Go)
- On fournit un nom ("tinyblog") pour la base de données (Database name)
- On clique sur "Create new MongoDB deployment",
- En cliquant sur le nom de la base Mongo, on accède à l'écran de configuration,
-- Les paramètres de configuration sont dans l'URL,
-- On clique sur l'onglet "Users", puis le bouton "Add database user" pour ajouter un nouvel utilisateur,

!!!! Configuration du compte

Pensez à changer les valeurs!

[[[
|Champs       |Valeur                  |
|-------------|------------------------|
|Account name |tinyblog                |
|Username     |tinyblog                |
|Email        |olivier.auverlot@free.fr|
|Password     |tinyblog2015            |
]]]

!!!! Paramètres du serveur

[[[
|Parametre      |Valeur                |
|---------------|----------------------|
|Serveur        |ds045064.mongolab.com |
|Port           |45064                 |
|Nom de la base |tinyblog              |
]]]

!!!! Utilisateur de la base tinyblog

[[[
|Champs       |Valeur      |
|-------------|------------|
|Compte       |tbuser      |
|Mot de passe |tbpassword  |
]]]

!!! Installation locale

!!!! Mac OS X

- Installer Brew (*http://brew.sh*)

- Dans le terminal, mettre à jour les paquets et installer MongoDB:

[[[
brew update
brew install mongodb
]]]

- Créer un répertoire pour le stockage des données et attribution des droits

[[[
mkdir -p /data/db
chmod -R /data/db
]]]

Lancement de mongo: ==`sudo mongod`==

!!!! Linux Debian
Google pour le moment. A venir

!!!! Windows
Google pour le moment. A venir














! Le modèle de TinyBlog

Le modèle de tinyblog est extremement simple: Les deux classes ==TBPost== et  ==TBBlog==.

!!! La classe TBPost

[[[
Object subclass: #TBPost
   instanceVariableNames: 'title text date category visible'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

!!! Description d'un post

Cinq variables d'instance pour décrire un post sur le blog.

[[[
|Variable      |Signification                |
|--------------|-----------------------------|
|title         |Titre du post                |
|text          |Texte du post                |
|date          |Date de redaction            |
|category      |Rubrique contenant le post   |
|visible       |Post visible ou pas ?        |
]]]

Ces variables ont des setters et getters dans le protocole accessing.

[[[
TBPost >> title
   ^ title

TBPost >> title: anObject
   title := anObject

TBPost >> text
   ^ text

TBPost >> text: anObject
   text := anObject

TBPost >> date
   ^ date

TBPost >> date: anObject
   date := anObject

TBPost >> visible
   ^ visible

TBPost >> visible: anObject
   visible := anObject

TBPost >> category
   ^ category

TBPost >> category: anObject
   category := anObject
]]]

!!!! Initialisation

La méthode 'initialize' (protocole ==initialize-release==) fixe par défaut la date et fixe par défaut la visibilité à false (l'utilisateur devra par la suite activer la visibilité ce qui permet de rédiger des brouillons et de publier lors que le post est terminé). Un post est également rangé par défaut dans la catégorie "Unclassified" que l'on définit au niveau classe. 

[[[
TBPost >> initialize
  self category: TBPost unclassifiedTag.
  self date: Date today.
  self visible: false.
]]]

[[[
TBPost class >> unclassifiedTag
   ^'Unclassified'
]]]


!!!! Amélioration
Il serait préférable de ne pas faire une référence en dur à la class ==TBPost== comme dans la méthode ==initialize==.
Proposer une solution.


!!!! Instance création API

Coté classe, on définit que ==TBPost== est un objet géré par Voyage et on spécifie des méthodes pour faciliter la création de post appartenant ou pas à une catégorie. La méthode ==unclassifiedTag== renvoie une valeur indiquant que le post n'est pas rangé dans une catégorie.


[[[
TBPost class >> isVoyageRoot
   ^true

TBPost class >> title: aTitle text: aText
   ^ self new
      title: aTitle;
      text: aText

TBPost class >> title: aTitle text: aText category: aCategory
   ^ self new
      title: aTitle;
      text: aText;
      category: aCategory
]]]


!!!! Test

Savoir si un post est classé dans une catégorie

[[[
TBPost >> isUnclassified
   ^ self category = TBPost unclassifiedTag
]]]

Il serait préférable de ne pas faire une référence en dur à la class TBPost.
Proposer une solution.

!!!! Gérer la visibilité d'un post

Il faut avoir la possibilité d'indiquer qu'un post est visible ou pas. Il faut également pouvoir demandé à un post s'il est visible. Les méthodes sont définies dans la protocole 'action'.

[[[
TBPost >> beVisible
   self visible: true

TBPost >> notVisible
   self visible: false

TBPost >isVisible
   ^ self visible
]]]

!!! La classe TBBlog
La classe ==TBBlog== collecte les posts. Elle a aussi la responsabilité de la communication entre l'application et la base MongoDB. 

[[[
Object subclass: #TBBlog
   instanceVariableNames: 'repository host port database username password'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

!!!! Une seule base

Il y a une seule instance de la classe (singleton) et celle-ci est construite coté classe comme suit.

[[[
TBBlog class
   instanceVariableNames: 'uniqueInstance'

TBBlog class >> initialize
   ^ uniqueInstance ifNil: [ uniqueInstance := self new ]

TBBlog class >> current
   ^ uniqueInstance

TBBlog class >> reset
   VORepository setRepository: nil.
   uniqueInstance := nil
]]]

L'expression ==VORepository setRepository: nil.== est une expression Voyage qui initialize la connexion avec la base de données Mongo.


!!!! Initialisation de la connexion

Coté instance, les méthodes ==initializeConnectionParameters== et ==initialize== établissent la connexion vers la base de données.

[[[
TBBlog >> initializeConnectionParameters
   host := 'localhost'.
   database := 'tinyblog'
]]]
[[[
TBBlog >> initialize
   super initialize.
   self initializeConnectionParameters.
   
   repository := VOMongoRepository
      host: host
      "port: port"
      database: database.
      "username: username
      password: password"
   
   repository enableSingleton.
]]]

@@note Pas d'authentification utilisée car impossible de le faire avec MongoDB 3.0 (nouvelle méthode de chiffrement SCRAM pas encore supportée avec Pharo)



!! Tester les règles métiers
Nous allons écrire les tests pour les règles métiers et ceci en mode TDD (Test Driven Development) c'est-à-dire en développant les tests en premiers puis en définissant les fonctionalités jsuqu'à ce que les tests passent.

Les tests unitaires sont regroupés dans le paquet ==TinyBlog-tests== qui contient la classe ==TBBlogTest==.

[[[
TestCase subclass: #TBBlogTest
   instanceVariableNames: 'blog post repository'
   classVariableNames: ''
   package: 'TinyBlog-tests'
]]]

Avant le lancement des tests, la méthode ==setUp== initialise la connexion vers la base, efface son contenu, ajoute un post et en crée un autre qui provisoirement n'est pas enregistré.

[[[
TBBlogTest >> setUp
   repository := TBBlog initialize.
   blog := TBBlog current.

   blog removeAll.

   TBBlog current writeBlogPost: (TBPost title: 'A title' text: 'A text' category: 'First Category').
    post := (TBPost title: 'Another title' text: 'Another text' category: 'Second Category') beVisible
]]]

On en profite pour tester différentes configuration. Les posts ne sont pas dans la même catégorie, l'un est visible, l'autre pas.

La méthode ==tearDown== exécutée au terme des tests remet à zéro la connexion.

[[[
TBBlogTest >> tearDown
   TBBlog reset
]]]

??? why not repository reset since repository points to TBBlog initialize which returns the class

Nous allons développer les tests d'abord puis ensuite passer à l'implémentation
des fonctionalités.

!!!! Obtenir le nombre de posts dans la base

[[[
TBBlogTest >> testSize
   self assert: blog size equals: 1
]]]

!!!! Ajouter un post

[[[
TBBlogTest >> testAddBlogPost
   blog writeBlogPost: post.
   self assert: blog size equals: 2
]]]

!!!! Obtenir l'ensemble des posts (visibles et invisibles)

[[[
TBBlogTest >> testAllBlogPosts
   blog writeBlogPost: post.
   self assert: (blog allBlogPosts) size equals: 2.
]]]

!!!! Obtenir tous les posts visibles

[[[
TBBlogTest >> testAllVisibleBlogPosts
   blog writeBlogPost: post.
   self assert: (blog allVisibleBlogPosts) size equals: 1.
]]]

!!!! Obtenir tous les posts d'une catégorie

[[[
TBBlogTest >> testAllBlogPostsFromCategory
   self assert: (blog allBlogPostsFromCategory: 'First Category') size equals: 1
]]]

!!!! Obtenir tous les posts visibles d'une catégorie

[[[
TBBlogTest >> testAllVisibleBlogPostsFromCategory
   blog writeBlogPost: post.
   self assert: (blog allVisibleBlogPostsFromCategory: 'First Category') size equals: 0.
   self assert: (blog allVisibleBlogPostsFromCategory: 'Second Category') size equals: 1.
]]]

!!!! Vérifier la gestion des posts non classés

[[[
TBBlogTest >> testUnclassifiedBlogPosts
   self assert: (blog allBlogPosts select: [ :p | p isUnclassified ]) size equals: 0.
]]]

!!!! Obtenir la liste des catégories

[[[
TBBlogTest >> testAllCategories
   blog writeBlogPost: post.
   self assert: (blog allCategories) size equals: 2.
]]]

!!!! Effacer l'intégralité des posts

[[[
TBBlogTest >> testRemoveAllBlogPosts
   blog removeAll.
   self assert: blog size equals: 0.
]]]

!!! Implémentation des règles métiers

Les règles métiers sont regroupées dans le protocole 'action' de la classe ==TBBlog==.

!!!! Obtenir le nombre de posts dans la base

[[[
TBBlog >> size
   ^ repository count: TBPost
]]]

!!!! Enregistrer le contenu d'un post

Enregistrer le contenu d'un post est assez simple. On le sauve.
??? comment on sait que c'est dans la bonne base?
??? sans mongo j'aurais fait: posts add: aPost

[[[
TBBlog >> writeBlogPost: aPost
   aPost save.
]]]

!!!! Effacer l'ensemble des posts

[[[
TBBlog >> removeAll
   repository removeAll: TBPost
]]]

!!!! Obtenir l'ensemble des posts

[[[
TBBlog >> allBlogPosts
   ^ repository selectAll: TBPost
]]]

!!!! Obtenir l'ensemble des posts visibles

[[[
TBBlog >> allVisibleBlogPosts
   ^ (repository selectAll: TBPost) select: [ :p | p isVisible ]
]]]

!!!! Obtenir la liste des catégories

[[[
TBBlog >> allCategories
   ^(self allBlogPosts collect: [ :p | p category ]) asSet
]]]

!!!! Obtenir l'ensemble des posts d'une catégorie

[[[
TBBlog >> allBlogPostsFromCategory: aCategory
   ^repository selectMany: TBPost where: [ :p | p category = aCategory ]
]]]

!!!! Obtenir l'ensemble des posts visibles d'une catégorie

[[[
TBBlog >> allVisibleBlogPostsFromCategory: aCategory
   ^(repository selectMany: TBPost where: [ :p | p category = aCategory ]) select: [ :p | p isVisible ]
]]]

!! Futures Evolutions

Plusieurs évolutions peuvent être apportées telles que obtenir uniquement la liste des catégories contenant au moins un post visible, effacer une catégorie et les posts contenus, renommer un catégorie, déplacer un post d'une catégorie à une autre, rendre visible ou invisible une catégorie et son contenu, etc. Nous vous encourageons à les développer.





! Infrastructure Web

Nous commençons par définir une interface telle que celle que les utilisateurs la verrons. Dans un prochain chapitre nous développerons une interface d'administration que le possesseur du blog utilisera.
Nous allons définir des composants Seaside *http://www.seaside.st*. L'ouvrage de référence est disponible en ligne à *http://book.seaside.st*


!! Initialisation de l'application

Création d'une classe ==TBRootComponent== qui est le point d'entrée de l'application. Il sert à l'initialisation de l'application.

On déclare l'application au serveur Seaside, coté classe, dans le protocole 'initialize'. On en profite pour intégrer les dépendances du framework Bootstrap (les fichiers css et js seront stockés dans l'application).

[[[
TBRootComponent class >> initialize
   "self initialize"
   | app |
   app := WAAdmin register: self asApplicationAt: 'TinyBlog'.
   app
      addLibrary: JQDeploymentLibrary;
      addLibrary: JQUiDeploymentLibrary;
      addLibrary: TBSDeploymentLibrary
]]]

Dans un Playground, on peut exécuter ==TBRootComponent initialize== pour forcer l'exécution de la méthode ==initialize==. Notez que nous venons de la définir et donc il est nécessaire de l'exécuter pour en voir les bénéfices.

Les méthodes de classe ==initialize== sont invoquées automatiquement lors du chargement du package.

Une connexion sur le serveur Seaside ("Browse the applications installed in your image") permet de vérifier que l'application est bien enregistrée.

@todo  add Screenshot

Ajoutons également la méthode ==canBeRoot== afin de préciser que la classe ==TBRootComponent== est la première instanciée lors qu'un utilisateur se connecte sur l'application et représente une application et pas seulement un composant.

[[[
TBRootComponent >> canBeRoot
   ^ true
]]]

Ajoutons maintenant une méthode ==renderContentOn:== afin de vérifier que notre application répond bien. La méthode est une méthode d'instance dans le protocole rendering.

[[[
TBRootComponent >> renderContentOn: html
   html text: 'TinyBlog'
]]]

Connexion avec un navigateur sur *http://localhost:8080/TinyBlog*. La page doit apparaître.

@@todo ??? add Screenshot

Ajoutons maintenant des informations dans l'entête de la page HTML afin que TinyBlog ait un titre et soit une application HTML5. L'ensemble des composants visuels de l'application hériteront de ==TBRootComponent== et il ne sera donc pas nécessaire de reproduire cette opération.

[[[
TBRootComponent >> updateRoot: anHtmlRoot
   super updateRoot: anHtmlRoot.
   anHtmlRoot beHtml5.
   anHtmlRoot title: 'TinyBlog'.
]]]

@@todoa je suis confus si ils sont tous root et tous update alors c'est pas le basard? esteban

Dans le cadre du développement, automatisons la création d'un ensemble de posts à l'aide de la méthode ==createDemoPosts== dans la classe ==TBBlog==.


[[[
TBBlog class >> createDemoPosts

   self uniqueInstance
      writeBlogPost: ((TBPost title: 'Welcome in TinyBlog' text: 'TinyBlog is a small blog engine made with Pharo.' category: 'TinyBlog') visible: true).
      writeBlogPost: ((TBPost title: 'Report Pharo Sprint' text: 'Friday, June 12 there was a Pharo sprint / Moose dojo. It was a nice event with more than 15 motivated sprinters. With the help of candies, cakes and chocolate, huge work has been done' category: 'Pharo')visible: true).
      writeBlogPost: ((TBPost title: 'Brick on top of Bloc - Preview' text: 'We are happy to announce the first preview version of Brick, a new widget set created from scratch on top of Bloc. Brick is being developed primarily by Alex Syrel (together with Alain Plantec, Andrei Chis and myself), and the work is sponsored by ESUG. Brick is part of the Glamorous Toolkit effort and will provide the basis for the new versions of the development tools.' category: 'Pharo') visible: true).
      writeBlogPost: ((TBPost title: 'The sad story of unclassified blog posts' text: 'So sad that I can read this.') visible: true).
      writeBlogPost: ((TBPost title: 'Working with Pharo on the Raspberry Pi' text: 'Hardware is getting cheaper and many new small devices like the famous Raspberry Pi provide new computation power that was one once only available on regular desktop computers. This capable little device called Pi enables people of all ages to explore computing and combined with powerful software environments like Pharo the Pi can be used for interesting projects.' category: 'Pharo') visible: true).
]]]

!! Gestion de Session

Un objet session est attribué à chaque instance de l'application. Il permet de conserver principalement des informations. Nous allons voir comment nous l'utilisons pour gérer une connexion.

[[[
WASession subclass: #TBSession
   instanceVariableNames: 'repository'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

Nous allons l'utiliser pour fournir à chaque utilisateur la référence vers l'instance uniquement de ==TBBlog==.

[[[
TBSession >> repository
   ^ repository
]]]

[[[
TBSession >> repository: anObject
   repository := anObject
]]]

Le protocole 'initialize-release'' contient les méthodes ==initialize== et ==initializeRepository==. Celle-ci est appelée à chaque fois qu'un nouvel utilisateur se connecte à l'application (??? c'est quoi un nouvel utilisateur). Elle demande la création d'une instance de ==TBBlog== et celui-ci ne contient aucun posts, elle déclenche la création des posts de démonstration.

[[[
TBSession >> initializeRepository
   TBBlog initialize.
   self repository: TBBlog current.
   self repository size = 0 ifTrue: [ self repository createDemoPosts ]
]]]

[[[
TBSession >> initialize
   super initialize.
   self initializeRepository
]]]

Ajoutons maintenant une méthode ==initialize== dans le protocole 'initialize-release' de la classe ==TBRootComponent==.

[[[
TBRootComponent >> initialize
   super initialize.
   TBBlog initialize.
   self repository size = 0 ifTrue: [ self repository createDemoPosts ]
]]]

Il vous faut maintenant spécifier à Seaside qu'il doit utiliser l'objet ==TBSession== comme objet de session courant pour l'application TinyBlog. Pour cela, on utilise l'outil d'administration de Seaside.

- connexion sur `http://localhost:8080/config`,
- on clique sur "TinyBlog",
- Dans "General", cliquez sur le bouton "Override" de "Session Class",
- Choisir 'TBSession'' dans la liste déroulante,
- Cliquez sur le bouton "Apply" en bas du formulaire.

@@todo ça serait bien d'automatiser cette étape à l'initialisation de l'application. esteban










! Composants Visuels de TinyBlog

Nous sommes prets à définir les composants visuels de notre petite application.
Les premiers chapitre de *http://book.seaside.st* peuvent vous aider.


!! Le composant TBScreenComponent

[[[
WAComponent subclass: #TBScreenComponent
   instanceVariableNames: ''
   classVariableNames: ''
   package: 'TinyBlog'
]]]

Les différents composants d'interface de TinyBlog auront besoin d'accéder aux règles métier de l'application. Dans le protocole 'accessing', créons un méthode ==repository== qui retourne l'instance de ==TBBlog==. Celle-ci sera stockée dans la session de l'application et donc accessible dans tous les objets héritant de WAComponent (??? vraiment).

[[[
TBScreenComponent >> repository
   ^ self session repository
]]]

Profitons également de ce composant pour insérer dans la partie supérieure de chaque composant, l'instance d'un composant représentant l'entête de l'application.

!! Définition du composant TBHeaderComponent

[[[
WAComponent subclass: #TBHeaderComponent
   instanceVariableNames: ''
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

Le protocole 'rendering' contient la méthode ==renderContentOn:== chargée d'afficher l'entête.

[[[
TBHeaderComponent >> renderContentOn: html
   html tbsNavbar beDefault with: [
      html tbsNavbarBrand
         url: '#';
         with: 'TinyBlog' ]
]]]

L'entête est affichée à l'aide d'une barre de navigation Bootstrap.

!!!! Améliorations possibles
Le nom du blog devrait être paramêtrable à l'aide d'une variable d'instance dans un objet ==TBConfiguration== ou à l'aide d'un document dans la base Mongo.


!! Ajout d'un Header

Il n'est pas souhaitable d'instancier systématiquement le composant à chaque fois qu'un composant est appelé. Créons une variable d'instance ==header== dans ==TBScreenComponent== qui sera initialisés une seule fois pour chaque utilisateur de l'application (gain de ressources).

[[[
WAComponent subclass: #TBScreenComponent
   instanceVariableNames: 'header'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

Créons une méthode ==initialize== dans le protocole `initialize-release`:

[[[
TBScreenComponent >> initialize
   super initialize.
   header := TBHeaderComponent new.
]]]

!!! Relation Composite-Composant
Définissons que l'instance du composant ==TBHeaderComponent== est un enfant de ==TBScreenComponent== dans la hiérarchie de composants Seaside (en non entre classes Pharo). En effet en Seaside les sous-composants d'un composant doivent être retournés par le composite par le message ==children==.

[[[
TBScreenComponent >> children
   ^ OrderedCollection with: header
]]]

Affichons maintenant le composant dans la méthode ==renderContentOn:== (protocole 'rendering'):

[[[
TBScreenComponent >> renderContentOn: html
   self render: header
]]]

!!! Liste des Posts

Nous allons afficher la liste des posts (acces public). Dans le future, nous  proposerons une interface administrative des posts.

A l'aide du jeu de test, nous construisons le composant public de l'application qui affiche les blogs.

Créons un composant ==TBPublicPostsListComponent== qui hérite de ==TBScreenComponent==:

[[[
TBScreenComponent subclass: #TBPublicPostsListComponent
   instanceVariableNames: 'report'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

Ajoutons une méthode ==renderContentOn:== (protocole rendering) provisoire pour tester l'avancement de notre application.

[[[
TBPublicPostsListComponent >> renderContentOn: html
   super renderContentOn: html
   html text: 'Blog Posts here !!!'
]]]

Maintenant, revenons au composant ==TBRootComponent== et ajoutons une variable d'instance ==publicPostsList== qui contiendra (pour chaque utilisateur) l'instance du composant ==TBPublicPostsListComponent== (économie de ressources).
??? TBRootComponent = TBBlogComponent

[[[
WAComponent subclass: #TBRootComponent
   instanceVariableNames: 'publicPostsList'
   classVariableNames: ''
   package: 'TinyBlog'
]]]

[[[
TBRootComponent >> publicPostsList
   ^ publicPostsList
]]]
[[[
TBRootComponent >> publicPostsList: anObject
   publicPostsList := anObject
]]]
[[[
TBRootComponent >> registerSubComponents
   self publicPostsList: TBPublicPostsListComponent new
]]]
[[[
TBRootComponent >> initialize
   super initialize.
   self registerSubComponents
]]]

Children missing ???
[[[
TBRootComponent >> children
   ^ OrderedCollection with: publicPostsList
]]]




La méthode ==renderContentOn:== affiche, au démarrage de l'application, la liste des posts dans la base.

[[[
TBRootComponent >> renderContentOn: html
   html render: self publicPostsList
]]]

!! Le composant Post

Nous allons maintenant définir le composant ==TBPostContentComponent== qui affiche le contenu d'un post.

Chaque post du blog sera représenté visuellement par une instance de  ==TBPostContentComponent== qui affiche le titre, la date et le contenu d'un post.

[[[
WAComponent subclass: #TBPostContentComponent
   instanceVariableNames: 'title text date'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

[[[
TBPostContentComponent >> title
   ^ title

TBPostContentComponent >> title: anObject
   title := anObject

TBPostContentComponent >> text
   ^ text

TBPostContentComponent >> text: anObject
   text := anObject

TBPostContentComponent >> date
   ^ date

TBPostContentComponent >> date: anObject
   date := anObject
]]]

Créons une méthode de classe pour initialiser chaque post:

[[[
TBPostContentComponent class >> title: aTitle text: aText date: aDate
   ^ self new
      title: aTitle;
      text: aText;
      date: aDate
]]]

Ajoutons la méthode ==renderContentOn:== qui définie l'affichage du post.

[[[
TBPostContentComponent >> renderContentOn: html
   html heading level: 2; with: self title.
   html heading level: 6; with: self date.
   html text: self text
]]]

Nous montrerons dans le chapitre décrivant Magritte puis les interfaces d'administration, qu'il est rare
de définir un composant de manière aussi manuelle. En effet Magritte en décrivant les données manipuler
permet de générer automatiquement des composantes Seaside. Le code équivalent serait comme suit: 

[[[
TBPostContentComponent >> renderContentOn: html
   html render: self asComponent
]]]


!! Afficher les posts

Maintenant nous pouvons afficher des posts présents dans la base.

Il ne reste plus qu'à modifier la méthode ==TBPublicPostsListComponent >> renderContentOn:== pour afficher l'ensemble des blogs visibles présents dans la base.

[[[
TBPublicPostsListComponent >> renderContentOn: html
   super renderContentOn: html.
   self repository allVisibleBlogPosts do: [ :p |
      html render: (TBPostContentComponent
         title: p title
         text: p text
         date: p date).
   ]
]]]

!!! Affichage des posts par catégorie


!!! Categories

Nous allons créer un composant pour gérer une liste de catégories nommée: ==TBCategoriesListComponent==.

Les posts sont classés par catégorie. Par défaut, si aucune catégorie n'a été précisée, ils sont rangés dans une catégorie spéciale dénommée "Unclassified".

Nous avons besoin d'un composant Seaside qui affiche la liste des catégories présentes dans la base et permet d'en sélectionner une. Ce composant devra donc avoir la possibilité de communiquer avec le composant ==TBPublicPostsListComponent== afin de lui communiquer la catégorie choisie par l'utilisateur.

[[[
WAComponent subclass: #TBCategoriesListComponent
   instanceVariableNames: 'categories postsListScreen'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

[[[
TBCategoriesListComponent >> categories
   ^ categories

TBCategoriesListComponent >> categories: anObject
   categories := anObject

TBCategoriesListComponent >> postsListScreen
   ^ postsListScreen

TBCategoriesListComponent >> postsListScreen: anObject
   postsListScreen := anObject
]]]

[[[
TBCategoriesListComponent class >> categories: aCollectionOfCategories postsListScreen: aTBScreen
   ^self new categories: aCollectionOfCategories; postsListScreen: aTBScreen
]]]

La méthode ==selectCategory== (protocole 'action') communique au composant ==TBPublicPostsListComponent== la nouvelle catégorie courante.

[[[
TBCategoriesListComponent >> selectCategory: aCategory
   self postsListScreen currentCategory: aCategory
]]]

Nous avons donc besoin d'ajouter une variable d'instance dans ==TBPublicPostsListComponent==.

[[[
TBScreenComponent subclass: #TBPublicPostsListComponent
   instanceVariableNames: 'currentCategory'
   classVariableNames: ''
   package: 'TinyBlog-Components'
]]]

[[[
TBScreenComponent >> currentCategory
   ^ currentCategory

TBScreenComponent >> currentCategory: anObject
   currentCategory := anObject
]]]

Nous pouvons ajouter une méthode (protocole 'rendering') pour afficher les catégories sur la page.

[[[
??? >> renderCategoryLinkOn: html with: aCategory
   html tbsLinkifyListGroupItem
      callback: [ self selectCategory: aCategory ];
      with: aCategory
 
]]]

Reste maintenant à écrire la méthode de rendu du composant:

[[[
??? >> renderContentOn: html
   html tbsListGroup: [
      html tbsLinkifyListGroupItem beActive; with: 'Categories'.
      categories do: [ :c | self renderCategoryLinkOn: html with: c ].
   ]
]]]

!! Mise à jour des Posts
Nous devons aussi mettre à jour la liste des posts.

Il faut gérer le raffraîchissement de la liste des posts en fonction de la catégorie choisie et donc modifier la méthode de rendu du composant ==TBPublicPostsListComponent==.

La méthode ==readSelectedPosts== récupère dans la base les posts à afficher. Si elle vaut ==nil==, l'utilisateur n'a pas encore sélectionner une catégorie et l'ensemble des posts visibles de la base est affiché. Si elle contient une valeur autre que ==nil==, l'utilisateur a sélectionné une catégorie et l'application affiche alors la liste des posts attachés à la catégorie.

[[[
TBPublicPostsListComponent >> readSelectedPosts
   ^ self currentCategory
      ifNil: [ self repository allVisibleBlogPosts ]
      ifNotNil: [ self repository allVisibleBlogPostsFromCategory: self currentCategory  ].
]]]

@@todo Olivier maintenant on ne doit plus avoir besoin de faire un test car la caetgory est definie tout le temps

Nous pouvons maintenant modifier la méthode chargée du rendu de la liste des posts:

[[[
TBPublicPostsListComponent >> renderContentOn: html
   super renderContentOn: html.

   html render: (TBCategoriesListComponent
               categories: (self repository allCategories)
               postsListScreen: self).

   self readSelectedPosts do: [ :p |
      html render: (TBPostContentComponent
         title: p title
         text: p text
         date: p date).
   ]
]]]

Une instance du composant ==TBCategoriesListComponent== est ajoutée sur la page et permet de sélectionner la catégorie courante.


!! Look et Agencement

Nous allons maintenant agencer le composant ==TBPublicPostsListComponent==.

Mise en place d'un responsive design pour la liste des posts. Les composants sont placés dans un container Bootstrap puis agencés sur une ligne avec deux colonnes. La dimension des colonnes est déterminée en fonction de la résolution (viewport) du terminal utilisé. Les 12 colonnes de Bootstrap sont réparties entre la liste des catégories et la liste des posts. Dans le cas d'une résolution faible, la liste des catégories est placée au dessus de la liste des posts (chaque élément occupant 100\% de la largeur du container).

Tant que nous sommes dans les finitions, profitons en également pour afficher la date de chaque post dans un format compréhensible (sans l'heure).
[[[
TBPublicPostsListComponent >> renderContentOn: html

   super renderContentOn: html.
    html tbsContainer: [
      html tbsRow showGrid;
         with: [
            html tbsColumn
               extraSmallSize: 12;
               smallSize: 2;
               mediumSize:  4;
               with: [
                  html render: (TBCategoriesListComponent
                     categories: (self repository allCategories)
                     postsListScreen: self) ].
            html tbsColumn
               extraSmallSize: 12;
               smallSize: 10;
               mediumSize: 8;
               with: [ self readSelectedPosts do: [ :p |
                  html render: (TBPostContentComponent
                     title: p title
                     text: p text
                     date: p date asDate) ] ] ] ]
]]]



! Décrire les données avec Magritte

@@todo Pourquoi utiliser Magritte ? Il évite d'écrire à la main les formulaires, de valider les données, permet de générer des rapports. add reference au booklet

Dans ce chapitre, les cinq variables d'instance de l'objet ==TBPost== sont décrites à l'aide de Magritte. Ici, nous ne nous intéressons qu'aux données (les informations sur l'apparence des données dans l'application seront renseignées plus tard).

!! Descriptions 
Les cinq méthodes sont dans le protocole 'descriptions' de la classe ==TBPost==.

Le titre d'un post est une chaine de caractères devant être obligatoirement complétée.

[[[
TBPost >> descriptionTitle
   <magritteDescription>
   ^ MAStringDescription new
      accessor: #title;
      beRequired;
      yourself
]]]

Le texte d'un post est une chaine de caractères multi-lignes devant être obligatoirement complétée.

[[[
TBPost >> descriptionText
   <magritteDescription>
   ^ MAMemoDescription new
      accessor: #text;
      beRequired;
      yourself
]]]

La catégorie d'un post est une chaine de caractères qui peut ne pas être renseignée. Dans ce cas, le post sera de toute manière rangé dans la catégorie "Unclassified".

[[[
TBPost >> descriptionCategory
   <magritteDescription>
   ^ MAStringDescription new
      accessor: #category;
      yourself
]]]

La date de création d'un post est importante car elle permet de définir l'ordre de tri pour l'affichage des posts. C'est donc une variable d'instance contenant obligatoirement une date.

[[[
TBPost >> descriptionDate
   <magritteDescription>
   ^ MADateDescription new
      accessor: #date;
      beRequired;
      yourself
]]]



La variable d'instance 'visible'' doit obligatoirement contenir une valeur booléenne.

[[[
descriptionVisible
   <magritteDescription>
   ^ MABooleanDescription new
      accessor: #visible;
      beRequired;
      yourself
]]]
   
!!! Ameliorations possibles

Voici quelques améliorations

Nous pourrions améliorer cette description pour qu'il ne soit pas possible de poster un post ayant une date antèrieure celle d'ajourd'hui.

Nous pourrions changer la description d'une categorie pour en definir un enumere parmi les categories existantes. Ceci permettrait de faire une interface plus simplement.






!! Administration de TinyBlog

